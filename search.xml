<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ionic 连接蓝牙打印机打印小票]]></title>
    <url>%2F2018%2F12%2F24%2Fionic-%E8%BF%9E%E6%8E%A5%E8%93%9D%E7%89%99%E6%89%93%E5%8D%B0%E6%9C%BA%E6%89%93%E5%8D%B0%E5%B0%8F%E7%A5%A8%2F</url>
    <content type="text"><![CDATA[这篇写好的文章丢了TT。。。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192constructor( private ble: BLE, public plt: Platform, private router: Router, private cdf: ChangeDetectorRef ) &#123;&#125; scan() &#123; this.ble.scan([], 10).subscribe( device =&gt; &#123; this.device = device; this.devices.push(device); this.cdf.markForCheck(); // 进行标注 this.cdf.detectChanges(); // 要多加一行这个 执行一次变化检测 &#125;, err =&gt; &#123; alert(JSON.stringify(err)); &#125; ); &#125; onConnect(device) &#123; this.ble.connect(device.id).subscribe( result =&gt; &#123; alert(JSON.stringify(result)); this.status = result; this.getBleInfo(); this.deviceId = device.id; &#125;, err =&gt; &#123; alert(JSON.stringify(err)); &#125; ); &#125; getBleInfo() &#123; const array = this.status.characteristics; for (let index = 0; index &lt; array.length; index++) &#123; const element = array[index]; if (element.properties.indexOf(&quot;Write&quot;) &gt; -1) &#123; this.serviceUUID = element.service; this.characteristicUUID = element.characteristic; return false; &#125; &#125; &#125; print(content) &#123; const intarray: number[] = []; for (let index = 0; index &lt; content.length; index++) &#123; const u = content.charCodeAt(index); const uindex = this.encode.wUnicodes.indexOf(u); if (uindex === -1) &#123; intarray.push(u); &#125; else &#123; const g = this.encode.wGBKs[uindex]; const gstr = g.toString(2); // 转二进制字符串 const pint = gstr.substring(0, 8); // 截取前八位 intarray.push(parseInt(pint, 2)); if (gstr.length &gt; 8) &#123; const lint = gstr.substring(8); intarray.push(parseInt(lint, 2)); &#125; &#125; &#125; const array = new Uint8Array(intarray.length); for (let index = 0; index &lt; intarray.length; index++) &#123; const element = intarray[index]; array[index] = element; &#125; this.ble .write( this.deviceId, this.serviceUUID, this.characteristicUUID, array.buffer ) .then(e =&gt; &#123; alert(&quot;suceess:&quot; + JSON.stringify(e)); &#125;) .catch(e =&gt; &#123; alert(&quot;error:&quot; + JSON.stringify(e)); &#125;); &#125;]]></content>
      <tags>
        <tag>Ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用angular路由复用策略实现标签栏效果]]></title>
    <url>%2F2018%2F11%2F08%2F%E4%BD%BF%E7%94%A8angular%E8%B7%AF%E7%94%B1%E5%A4%8D%E7%94%A8%E7%AD%96%E7%95%A5%E5%AE%9E%E7%8E%B0%E6%A0%87%E7%AD%BE%E6%A0%8F%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[前段时间在后台管理端要实现的一个需求是做个类似浏览器中的标签栏。方便用户在不同报表中查看和比对。查了一些方法，可以通过angular的动态组件方式实现和路由复用的方式实现。 动态组件大体上就是把每个打开的页放入到componentFactory中，然后判断当前应该显示哪个页就好了。 简化的例子，请点击这里。 路由复用显然这种方式是更合理的，首先实现RouteReuseStrategy中的方法，判断各路由是否使用复用、存储和删除。 app.module.ts 123providers: [ &#123;provide: RouteReuseStrategy, useClass: SimpleReuseStrategy &#125;, ... simpleReuseStrategy.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 export class SimpleReuseStrategy implements RouteReuseStrategy &#123; public static handlers: &#123; [key: string]: DetachedRouteHandle &#125; = &#123;&#125;; private static waitDelete: string; public static deleteRouteSnapshot(name: string): void &#123; if (SimpleReuseStrategy.handlers[name]) &#123; delete SimpleReuseStrategy.handlers[name]; &#125; else &#123; SimpleReuseStrategy.waitDelete = name; &#125; &#125; public static getRouteUrl(route: ActivatedRouteSnapshot) &#123; return route[&apos;_routerState&apos;].url.replace(/\/|\?|&amp;|=/g, &apos;_&apos;); &#125; /** 表示对所有路由允许复用 如果你有路由不想利用可以在这加一些业务逻辑判断 */ public shouldDetach(route: ActivatedRouteSnapshot): boolean &#123; if (!route.routeConfig || route.routeConfig.loadChildren ||!route.routeConfig.data || (route.routeConfig.data&amp;&amp;!route.routeConfig.data.useCache)) &#123; return false; &#125; return true; &#125; /** 当路由离开时会触发。按url作为key存储路由快照&amp;组件当前实例对象 */ public store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle): void &#123; const routeKey = SimpleReuseStrategy.getRouteUrl(route); if (SimpleReuseStrategy.waitDelete &amp;&amp; SimpleReuseStrategy.waitDelete === routeKey) &#123; // 如果待删除是当前路由则不存储快照 SimpleReuseStrategy.waitDelete = null; return; &#125; SimpleReuseStrategy.handlers[routeKey] = handle; &#125; /** 若 url 在缓存中有的都认为允许还原路由 */ public shouldAttach(route: ActivatedRouteSnapshot): boolean &#123; let isShow = route.routeConfig.data&amp;&amp;route.routeConfig.data.useCache; return !!SimpleReuseStrategy.handlers[SimpleReuseStrategy.getRouteUrl(route)]&amp;&amp;isShow; &#125; /** 从缓存中获取快照，若无则返回nul */ public retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle &#123; if (!route.routeConfig) &#123; return null; &#125; // if (route.routeConfig.loadChildren) return null; const routeKey = SimpleReuseStrategy.getRouteUrl(route); return SimpleReuseStrategy.handlers[routeKey]; &#125; /** 进入路由触发，判断是否同一路由 */ public shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean &#123; const a = future.routeConfig === curr.routeConfig &amp;&amp; JSON.stringify(future.params) === JSON.stringify(curr.params); return a; &#125;&#125; 这里是我处理路由事件和标签栏的service，需要注意的要订阅的是 ActivationEnd 这路由事件。它会带有当前的路由信息。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788export class DealWithTabService &#123; tabList: Array&lt;Tab&gt; = []; tabsMaxLength = 15; constructor(public router: Router) &#123; abp.event.on(&apos;Tab.sendTabList&apos;, () =&gt; &#123; abp.event.trigger(&apos;getTabList&apos;, (this.tabList)); &#125;); this.router.events.filter(event =&gt; event instanceof ActivationEnd) .subscribe((event) =&gt; &#123; const snapshot = (event as ActivationEnd).snapshot; if (snapshot[&apos;_routerState&apos;].url &amp;&amp; snapshot.routeConfig.data &amp;&amp; snapshot.routeConfig.data.useCache) &#123; let key = snapshot[&apos;_routerState&apos;].url.replace(/\/|\?|&amp;|=/g, &apos;_&apos;); const exitMenu = this.tabList.find(info =&gt; info.url === key); if (exitMenu) &#123; this.tabList.forEach(p =&gt; p.isSelect = p.url === key); return; &#125; let title = snapshot.routeConfig.data.title; this.getTab(snapshot.routeConfig, snapshot.queryParams, snapshot[&apos;_routerState&apos;].url, title); &#125; &#125;); &#125; public getTab(routeConfig, queryParams, url, title) &#123; let isShow = routeConfig.data &amp;&amp; routeConfig.data.useCache; if (!isShow) &#123; return; &#125; let key = url.replace(/\/|\?|&amp;|=/g, &apos;_&apos;); const exitMenu = this.tabList.find(info =&gt; &#123; info.isSelect = false; return info.url === key; &#125;); if (exitMenu) &#123; // 如果存在不添加，当前表示选中 this.tabList.forEach(p =&gt; p.isSelect = p.url === key); return; &#125; let title1 = (queryParams &amp;&amp; queryParams.title) ? &apos;[&apos; + queryParams.title + &apos;]&apos; : &apos;&apos;; const tab = &#123; title: title + title1, module: routeConfig.data.module, queryParams: queryParams, // 因为我使用了queryParams传参，不建议，我的感觉，处理起来麻烦很多 url: key, isSelect: true &#125;; this.tabList.push(tab); this.sliceTabs(); &#125; public deleteTabCache(tab: Tab) &#123; // 当前关闭的是第几个路由 const index = this.tabList.findIndex(p =&gt; p.url === tab.url); // 如果只有一个不可以关闭 if (this.tabList.length === 1) &#123; return; &#125; if (tab.isSelect) &#123; // 显示上一个选中 let menu = this.tabList[index - 1]; if (!menu) &#123; // 如果上一个没有下一个选中 menu = this.tabList[index + 1]; &#125; // console.log(menu); // console.log(this.menuList); this.tabList.forEach(p =&gt; p.isSelect = p.url === menu.url); // 显示当前路由信息 this.routerNavigate(menu); &#125; this.tabList = this.tabList.filter(p =&gt; p.url != tab.url); // 删除复用 SimpleReuseStrategy.deleteRouteSnapshot(tab.url); this.sliceTabs(); &#125; ...&#125;]]></content>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic v4修改组件样式]]></title>
    <url>%2F2018%2F11%2F06%2F%E4%BF%AE%E6%94%B9%E7%BB%84%E4%BB%B6%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[新项目使用Ionic 4, Ionic 4的组件使用了shadow DOM和CSS4变量。我们需要注意API文档中的 CSS Custom Properties假如我们想要修改ion-item组件的背景颜色。我们可以在home.page.scss中这样写： 1234ion-item &#123; --ion-item-background-color-active: #000; --min-height: 100px;&#125; 在 theme/variables.scss中 使用 :root 选择器进行全局修改：123:root &#123; --ion-item-background-color-active: #000;&#125; 关于Ionic v4的shadow DOM推荐这篇文章《Shadow DOM Usage in Ionic Web Components》 关于CSS4变量可以参考《A Primer on CSS 4 Variables for Ionic 4》 还有一篇关于Ionic slot《Understanding How Slots are Used in Ionic 4》]]></content>
      <tags>
        <tag>Ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular Http拦截器]]></title>
    <url>%2F2018%2F11%2F04%2FangularHttp%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[当后台使用c#的abp框架时，而前端不使用abp带的angular模版，比如ionic项目，项目接口还是使用swagger生成，这是我们还是需要在请求头上带有token、tenantId信息、包括一些错误处理，可以仿造abp自带模版自己写个http拦截器。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318import &#123;Observable, of, Subject&#125; from &apos;rxjs&apos;;import &#123;MessageService&#125; from &apos;./message.service&apos;;import &#123;HttpInterceptor, HttpHandler, HttpRequest, HttpEvent, HttpResponse, HttpHeaders&#125; from &apos;@angular/common/http&apos;;import &#123;Injectable, Injector&#125; from &apos;@angular/core&apos;;export interface IValidationErrorInfo &#123; message: string; members: string[];&#125;export interface IErrorInfo &#123; code: number; message: string; details: string; validationErrors: IValidationErrorInfo[];&#125;export interface IAjaxResponse &#123; success: boolean; result?: any; targetUrl?: string; error?: any; unAuthorizedRequest: boolean; __abp: boolean;&#125;@Injectable()export class AbpHttpConfiguration &#123; constructor(private _messageService: MessageService) &#123; &#125; defaultError = &#123; message: &apos;产生了一个错误!&apos;, details: &apos;服务器没有发送错误详情.&apos; &#125;; defaultError401 = &#123; message: &apos;您未经过身份验证!&apos;, details: &apos;为了执行此操作，您应该进行身份验证(登录).&apos; &#125;; defaultError403 = &#123; message: &apos;您没有权限!&apos;, details: &apos;您不能执行此操作.&apos; &#125;; defaultError404 = &#123; message: &apos;未找到相关资源!&apos;, details: &apos;服务器上找不到请求的资源.&apos; &#125;; logError(error): void &#123; console.log(error); &#125; showError(error): any &#123; if (error.details) &#123; return this._messageService.error(error.details, error.message || this.defaultError.message); &#125; else &#123; return this._messageService.error(error.message || this.defaultError.message); &#125; &#125; handleTargetUrl(targetUrl: string): void &#123; if (!targetUrl) &#123; location.href = &apos;/&apos;; &#125; else &#123; location.href = targetUrl; &#125; &#125; handleUnAuthorizedRequest(messagePromise: any, targetUrl?: string): void &#123; const _this = this; const self = this; if (messagePromise) &#123; messagePromise.done(function () &#123; _this.handleTargetUrl(targetUrl || &apos;/&apos;); &#125;); &#125; else &#123; self.handleTargetUrl(targetUrl || &apos;/&apos;); &#125; &#125; handleNonAbpErrorResponse(response: HttpResponse&lt;any&gt;): void &#123; const self = this; switch (response.status) &#123; case 401: self.handleUnAuthorizedRequest(self.showError(self.defaultError401), &apos;/&apos;); break; case 403: self.showError(self.defaultError403); break; case 404: self.showError(self.defaultError404); break; default: self.showError(self.defaultError); break; &#125; &#125; handleAbpResponse(response: HttpResponse&lt;any&gt;, ajaxResponse: IAjaxResponse): HttpResponse&lt;any&gt; &#123; let newResponse; if (ajaxResponse.success) &#123; newResponse = response.clone(&#123; body: ajaxResponse.result &#125;); if (ajaxResponse.targetUrl) &#123; this.handleTargetUrl(ajaxResponse.targetUrl); &#125; &#125; else &#123; newResponse = response.clone(&#123; body: ajaxResponse.result &#125;); if (!ajaxResponse.error) &#123; ajaxResponse.error = this.defaultError; &#125; this.logError(ajaxResponse.error); this.showError(ajaxResponse.error); if (response.status === 401) &#123; this.handleUnAuthorizedRequest(null, ajaxResponse.targetUrl); &#125; &#125; return newResponse; &#125; getAbpAjaxResponseOrNull(response: HttpResponse&lt;any&gt;): IAjaxResponse | null &#123; if (!response || !response.headers) &#123; return null; &#125; const contentType = response.headers.get(&apos;Content-Type&apos;); if (!contentType) &#123; // this._logService.warn(&apos;Content-Type is not sent!&apos;); console.warn(&apos;Content-Type is not sent!&apos;); return null; &#125; if (contentType.indexOf(&apos;application/json&apos;) &lt; 0) &#123; // this._logService.warn(&apos;Content-Type is not application/json: &apos; + contentType); console.log(&apos;Content-Type is not application/json: &apos; + contentType); return null; &#125; const responseObj = JSON.parse(JSON.stringify(response.body)); if (!responseObj.__abp) &#123; return null; &#125; return responseObj; &#125; handleResponse(response: HttpResponse&lt;any&gt;): HttpResponse&lt;any&gt; &#123; const ajaxResponse = this.getAbpAjaxResponseOrNull(response); if (ajaxResponse == null) &#123; return response; &#125; return this.handleAbpResponse(response, ajaxResponse); &#125; blobToText(blob: any): Observable&lt;string&gt; &#123; return new Observable(function (observer) &#123; if (!blob) &#123; observer.next(&apos;&apos;); observer.complete(); &#125; else &#123; const reader = new FileReader(); reader.onload = function () &#123; observer.next(this.result); observer.complete(); &#125;; reader.readAsText(blob); &#125; &#125;); &#125;&#125;@Injectable()export class AbpHttpInterceptor implements HttpInterceptor &#123; protected configuration: AbpHttpConfiguration; // private _tokenService; // private _utilsService; constructor(private injector: Injector) &#123; this.configuration = this.injector.get(AbpHttpConfiguration); // 使用inject注入service &#125; intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; const _this = this; const interceptObservable: Subject&lt;HttpEvent&lt;any&gt;&gt; = new Subject(); const modifiedRequest = this.normalizeRequestHeaders(request); next.handle(modifiedRequest) .subscribe(function (event) &#123; _this.handleSuccessResponse(event, interceptObservable); &#125;, function (error) &#123; return _this.handleErrorResponse(error, interceptObservable); &#125;); return interceptObservable; &#125; protected normalizeRequestHeaders(request: HttpRequest&lt;any&gt;): HttpRequest&lt;any&gt; &#123; let modifiedHeaders = new HttpHeaders(); modifiedHeaders = request.headers.set(&apos;Pragma&apos;, &apos;no-cache&apos;) .set(&apos;Cache-Control&apos;, &apos;no-cache&apos;) .set(&apos;Expires&apos;, &apos;Sat, 01 Jan 2000 00:00:00 GMT&apos;); modifiedHeaders = this.addXRequestedWithHeader(modifiedHeaders); modifiedHeaders = this.addAuthorizationHeaders(modifiedHeaders); modifiedHeaders = this.addAspNetCoreCultureHeader(modifiedHeaders); modifiedHeaders = this.addAcceptLanguageHeader(modifiedHeaders); modifiedHeaders = this.addTenantIdHeader(modifiedHeaders); return request.clone(&#123; headers: modifiedHeaders &#125;); &#125; protected addXRequestedWithHeader(headers: HttpHeaders): HttpHeaders &#123; if (headers) &#123; headers = headers.set(&apos;X-Requested-With&apos;, &apos;XMLHttpRequest&apos;); &#125; return headers; &#125; protected addAspNetCoreCultureHeader(headers: HttpHeaders): HttpHeaders &#123; // todo: 如果需要再添加.AspNetCore.Culture /*const cookieLangValue = this._utilsService.getCookieValue(&apos;Abp.Localization.CultureName&apos;); if (cookieLangValue &amp;&amp; headers &amp;&amp; !headers.has(&apos;.AspNetCore.Culture&apos;)) &#123; headers = headers.set(&apos;.AspNetCore.Culture&apos;, cookieLangValue); &#125;*/ return headers; &#125; protected addAcceptLanguageHeader(headers: HttpHeaders): HttpHeaders &#123; // todo: 如果需要再添加Accept-Language /*const cookieLangValue = this._utilsService.getCookieValue(&apos;Abp.Localization.CultureName&apos;); if (cookieLangValue &amp;&amp; headers &amp;&amp; !headers.has(&apos;Accept-Language&apos;)) &#123; headers = headers.set(&apos;Accept-Language&apos;, cookieLangValue); &#125;*/ return headers; &#125; protected addTenantIdHeader(headers: HttpHeaders): HttpHeaders &#123; // todo: 如果需要再添加Abp.TenantId // const cookieTenantIdValue = this._utilsService.getCookieValue(&apos;Abp.TenantId&apos;); // if (cookieTenantIdValue &amp;&amp; headers &amp;&amp; !headers.has(&apos;Abp.TenantId&apos;)) &#123; // headers = headers.set(&apos;Abp.TenantId&apos;, cookieTenantIdValue); // &#125; return headers; &#125; protected addAuthorizationHeaders(headers: HttpHeaders): HttpHeaders &#123; let authorizationHeaders = headers ? headers.getAll(&apos;Authorization&apos;) : null; if (!authorizationHeaders) &#123; authorizationHeaders = []; &#125; if (!this.itemExists(authorizationHeaders, function (item) &#123; return item.indexOf(&apos;Bearer &apos;) === 0; &#125;)) &#123; /*const token = this._tokenService.getToken(); if (headers &amp;&amp; token) &#123; headers = headers.set(&apos;Authorization&apos;, &apos;Bearer &apos; + token); &#125;*/ &#125; return headers; &#125; protected handleSuccessResponse(event: HttpEvent&lt;any&gt;, interceptObservable: Subject&lt;HttpEvent&lt;any&gt;&gt;): void &#123; const self = this; if (event instanceof HttpResponse) &#123; if (event.body instanceof Blob &amp;&amp; event.body.type &amp;&amp; event.body.type.indexOf(&apos;application/json&apos;) &gt;= 0) &#123; const clonedResponse = event.clone(); self.configuration.blobToText(event.body).subscribe(function (json) &#123; const responseBody = json === &apos;null&apos; ? &#123;&#125; : JSON.parse(json); const modifiedResponse = self.configuration.handleResponse(event.clone(&#123; body: responseBody &#125;)); interceptObservable.next(modifiedResponse.clone(&#123; body: new Blob([JSON.stringify(modifiedResponse.body)], &#123;type: &apos;application/json&apos;&#125;) &#125;)); interceptObservable.complete(); &#125;); &#125; else &#123; interceptObservable.next(event); interceptObservable.complete(); &#125; &#125; &#125; protected handleErrorResponse(error: any, interceptObservable: Subject&lt;HttpEvent&lt;any&gt;&gt;): Observable&lt;any&gt; &#123; const _this = this; const errorObservable = new Subject(); if (!(error.error instanceof Blob)) &#123; interceptObservable.error(error); interceptObservable.complete(); return of(&#123;&#125;); &#125; this.configuration.blobToText(error.error).subscribe(function (json) &#123; const errorBody = (json === &apos;&apos; || json === &apos;null&apos;) ? &#123;&#125; : JSON.parse(json); const errorResponse = new HttpResponse(&#123; headers: error.headers, status: error.status, body: errorBody &#125;); const ajaxResponse = _this.configuration.getAbpAjaxResponseOrNull(errorResponse); if (ajaxResponse != null) &#123; _this.configuration.handleAbpResponse(errorResponse, ajaxResponse); &#125; else &#123; _this.configuration.handleNonAbpErrorResponse(errorResponse); &#125; errorObservable.complete(); // prettify error object. error.error = errorBody; interceptObservable.error(error); interceptObservable.complete(); &#125;); return errorObservable; &#125; private itemExists&lt;T&gt;(items, predicate) &#123; for (let i = 0; i &lt; items.length; i++) &#123; if (predicate(items[i])) &#123; return true; &#125; &#125; return false; &#125;&#125; 在 app.module.ts中使用 1234 ...providers: [ &#123; provide: HTTP_INTERCEPTORS, useClass: AbpHttpInterceptor, multi: true &#125;, ...]]></content>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular/ionic自定义click]]></title>
    <url>%2F2018%2F10%2F12%2F%E8%87%AA%E5%AE%9A%E4%B9%89click%2F</url>
    <content type="text"><![CDATA[项目既要用于PC网页，又要在iPad之类的移动设备上使用。在iPad上的这种大屏设备上用户的手指点击按钮时，可能会发生一个细微的位移导致不能触发click事件。会给用户一种不太灵敏的感觉，为解决此问题写一个指令代替click。 直接贴上代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Directive(&#123; selector: &apos;[yun-click]&apos;&#125;)export class YunClickDirective implements OnInit, OnDestroy &#123; @Output(&apos;yun-click&apos;) eventClick = new EventEmitter(); unsubscribe: () =&gt; void; constructor(private platform: Platform, private renderer: Renderer2, private element: ElementRef) &#123; &#125; ngOnInit() &#123; if (this.platform.is(&apos;mobile&apos;) || this.platform.is(&apos;mobileweb&apos;) || this.platform.is(&apos;phablet&apos;) || this.platform.is(&apos;tablet&apos;)) &#123; this.yunTouch(); &#125; else &#123; this.yunClick(); &#125; &#125;// touch事件，移动端且滑动距离小于30px时触发 yunTouch() &#123; let startX, startY, endX, endY; // 监听touchstart this.unsubscribe = this.renderer.listen( this.element.nativeElement, &apos;touchstart&apos;, (event: TouchEvent) =&gt; &#123; let touch = event.targetTouches[0]; startX = touch.pageX; startY = touch.pageY; console.log(startX, startY); &#125;); // 监听touchmove this.unsubscribe = this.renderer.listen( this.element.nativeElement, &apos;touchmove&apos;, (event: TouchEvent) =&gt; &#123; let touch = event.targetTouches[0]; endX = touch.pageX; endY = touch.pageY; console.log(endX, endY); &#125;); // 监听touchend this.unsubscribe = this.renderer.listen( this.element.nativeElement, &apos;touchend&apos;, (event: TouchEvent) =&gt; &#123; let distanceX = Math.abs(endX - startX), distanceY = Math.abs(endY - startY); console.log(distanceX, distanceY); let distance = Math.sqrt((Math.pow(distanceX, 2) + Math.pow(distanceY, 2))); // 计算滑动距离 console.log(distance); if (distance &lt; 30 || !endX || !endY) &#123; // 没有滑动时，不触发touchmove，需要判断 this.eventClick.emit(event); &#125; &#125;); &#125;// click事件 yunClick() &#123; this.unsubscribe = this.renderer.listen( this.element.nativeElement, &apos;click&apos;, event =&gt; &#123; console.log(event); this.eventClick.emit(event); &#125;); &#125; ngOnDestroy() &#123; this.unsubscribe(); &#125;&#125; 使用时和click一样使用，把click换成yun-click。哦 不要忘记添加到module里。]]></content>
      <tags>
        <tag>Ionic</tag>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ng-events类似ionic中Events的angualr全局事件]]></title>
    <url>%2F2018%2F09%2F03%2Fng-events%E7%B1%BB%E4%BC%BCionic%E4%B8%ADEvents%E7%9A%84angualr%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[介绍ng-events 在 Angular 2 以上的版本中使用，类似于 ionic 中的 Events。可以使用 ng-events 注册一个全局事件，然后在需要的时候触发这个事件。 GitHub地址 快速开始1npm install ng-events --save 在 Angular 6 以上的版本中使用,修改 angular.json 文件, 在Angular 6以下版本中使用，修改.angular-cli.json文件 1234&quot;scripts&quot;: [ &quot;node_modules/ng-events/dist/ng-events.js&quot; // ... ] 当然也可以直接在index.html中引入，不过并不推荐这么做。 注册事件 你可以使用 ngEevents.on 注册一个全局事件: 123ngEvents.on(&apos;eventName&apos;, function (item) &#123; console.log(item.name + &apos; was selected!&apos;);&#125;); 第一个参数是事件的唯一名称。 第二个参数是在触发指定事件时调用的回调函数。 您可以使用 ngEvents.off 方法取消注册的事件。 触发事件使用 ngEvents.trigger 触发一个全局事件: 1234ngEvents.trigger(&apos;eventName&apos;, &#123; id: 42, name: &apos;Pencil&apos;&#125;); 第一个参数是事件的唯一名称. 第二个是（可选）事件参数。你可以添加任意数量的参数并在回调方法中获取它们。]]></content>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用RxJS处理超时]]></title>
    <url>%2F2018%2F04%2F16%2F%E4%BD%BF%E7%94%A8rxjs%E5%A4%84%E7%90%86%E8%B6%85%E6%97%B6%2F</url>
    <content type="text"><![CDATA[使用场景用户进行一个操作请求后台而长时间未响应，我们希望给用户一个信息展示（请求超时，网络不好…）. RxJS实现关于RxJS请看这里 我这个功能的实现主要使用 delay，race两个操作符。 delay 通过给定的超时或者直到一个给定的时间来延迟源 Observable 的发送。延迟时间(以毫秒为单位的数字)或 Date 对象(发送延迟到这个时间点)。 race 返回 Observable，该 Observable 是源 Observable 和提供的 Observables 的组合中 第一个发出项的 Observable 的镜像。 具体实现过程代码（使用angualr和ionic）如下：我封装成了service方便使用。主要看timeoutDeal方法。service.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import &#123; Injectable &#125; from &quot;@angular/core&quot;;import &#123; delay, map, race &#125; from &quot;rxjs/operators&quot;;import &#123; Observable &#125; from &quot;rxjs/Observable&quot;;import &#123; AlertController, LoadingController &#125; from &quot;ionic-angular&quot;;@Injectable()export class HttpTimeoutService &#123; loading: any; timer: any; timers:any[]=[]; constructor(private loadingCtrl: LoadingController, private alertCtrl: AlertController) &#123; &#125; // **参数name和参数mes相同 showLoading(name) &#123; const self = this; let obj=&#123;name:name,timer:undefined,loading:undefined&#125;; const timer = setTimeout(() =&gt; &#123; let loading = this.loadingCtrl.create(); loading.present(); obj.loading=loading; &#125;, 500); obj.timer=timer; this.timers.push(obj); &#125; clearTimer(name) &#123; const self = this; for(let i=0;i&lt;this.timers.length;i++)&#123; if(this.timers[i].name===name)&#123; if(this.timers[i].loading)&#123; this.timers[i].loading.dismiss(); &#125; clearTimeout(this.timers[i].timer); this.timers.splice(i,1); return; &#125; &#125; &#125; timeoutDeal(mes) &#123; const self = this; let TIME_OUT = 6000; let cancel$ = Observable.of(null).pipe(delay(TIME_OUT), map(_ =&gt; &#123; // throw &apos;error&apos;; self.clearTimer(mes); self.alertCtrl.create(&#123; title: &apos;连接超时&apos;, message: &apos;当前网络不稳定，请寻找一个稳定网络！&apos;, buttons: [&apos;确定&apos;] &#125;).present(); throw mes + &apos;timeout!&apos; &#125;)); return cancel$; &#125;&#125; pipe是 Observable 中有一个内置的 pipe 方法 (Observable.prototype.pipe)，它可以用类似于之前的链式调用的方式来组合操作符。RxJS 5.5版本之后。]]></content>
      <tags>
        <tag>RxJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic3踩坑体验（二）]]></title>
    <url>%2F2018%2F03%2F15%2Fionic3%E8%B8%A9%E5%9D%91%E4%BD%93%E9%AA%8C%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ios滚动卡顿&lt;ion-content&gt;滚动在ios会卡住，当我在ios不使用-webkit-overflow-scrolling: touch时不会卡住但滚动效果实在是太糟糕了。 1234567891011121314151617181920ionViewDidLoad()&#123; if (this.platform.is(&apos;mobileweb&apos;) &amp;&amp; this.platform.is(&apos;ios&apos;)) &#123; const scrollElement = this.content.getScrollElement(); scrollElement.scrollTo(0, 1); this.content.ionScrollEnd.subscribe(evt =&gt; &#123; if ((this.content.contentHeight + 1) &lt; scrollElement.scrollHeight) &#123; if (scrollElement.scrollTop === 0) &#123; scrollElement.scrollTo(0, 1); &#125; else if ((scrollElement.scrollTop + this.content.contentHeight) === scrollElement.scrollHeight) &#123; scrollElement.scrollTo(0, (scrollElement.scrollTop - 1)); &#125; &#125; &#125;); &#125;&#125; 用上面的方法可以解决一些问题，不过，如果你的页面内容是组件加载后获取，应该在内容获取后在使用这个方法。这个问题在GitHub上的讨论 echars在ionic上的使用首先我们安装 typings 库，以及 ECharts：npm install typings echarts --global 然后，安装 ECharts 的 TypeScript 定义文件，这个文件来自社区贡献。npm install @types/echarts --save 现在，我们可以在 TypeScript 文件中访问 ECharts 库了：import * as echarts from &#39;echarts&#39;; 具体使用方法可以看这个教程 我主要想说的不是echarts的使用，而是使用后出现的问题 在使用echarts后，打包成ios app(使用 pwa 也会有这个问题))后下拉图形（按住tooltip）出现闪屏的情况，只需要在echarts的option中添加 showDelay: 200 即可1234567891011121314151617181920212223242526272829303132333435363738394041424344tooltip: &#123; trigger: &apos;axis&apos;, // formatter: function (params,ticket,callback) &#123; // console.log(params) // var res = &apos;&lt;div (click)=&quot;show()&quot;&gt;&apos; + params[0].name; // for (var i = 0, l = params.length; i &lt; l; i++) &#123; // res += &apos;&lt;br/&gt;&apos; + params[i].seriesName + &apos; : &apos; + params[i].value;// &#125;// res =res+&apos;&lt;/div&gt;&apos;// setTimeout(function ()&#123;// // 仅为了模拟异步回调// callback(ticket, res);// &#125;, 1000)// return &apos;loading&apos;;// &#125;, axisPointer: &#123; type: &apos;cross&apos;, crossStyle: &#123; color: &apos;#999&apos; &#125; &#125;, showDelay: 200 //防止抖动&#125;,legend: &#123; data: [&apos;星期一&apos;,&apos;星期二&apos;]&#125;,xAxis: [ &#123; type: &apos;category&apos;, data: xdata, axisPointer: &#123; type: &apos;shadow&apos; &#125;, axisLabel: &#123; interval:0,rotate:40 &#125;, &#125;],yAxis: [ &#123; type: &apos;value&apos;, name: yname, axisLabel: &#123; formatter: &apos;&#123;value&#125;&apos; &#125;, splitLine:&#123; show: false &#125; &#125;],series: series&#125; 点击ios端点击事件有300ms左右延迟，需在有click事件的地方加上 tappable 属性。 1&lt;div tappable (click)=&quot;myClick()&quot;&gt;点击事件&lt;/div&gt; 也可以使用 fastclick1import * as FastClick from &apos;fastclick&apos; 1FastClick[&apos;attach&apos;](document.body); 还有当我们使用大屏设备比如iPad pro时，手指斜着点过去，可能会用轻微位移，我们可能需要兼容这种问题，可以使用touch事件，在我们的项目中，我写了一个指令去代替click事件实现兼容，有空单独介绍。 input输入框这点不是关于ionic，而是ios的。为了提高用户体验，点击输入款修改输入时，我们应当自动全选内容（拖蓝）。 拖蓝(全选) 最简单的是直接调用input.select()（HTMLInputElement.select()）； 当输入框已经获得焦点的时候（当然），可以使用document.execCommand(‘SelectAll’)来全选输入框中的所有内容(The selectAll command)。 但是只有targetElement.type === ‘text’ ||targetElement.type === ‘search’ ||targetElement.type === ‘password’ ||targetElement.type === ‘url’ ||targetElement.type === ‘tel’可以使用setSelectionRange 不过，对于pc可以使用&lt;input type=&#39;number&#39; onfocus=&#39;this.select()&#39;/&gt;直接实现 在ios设备没有作用 使用onfocus=&#39;this.select();this.setSelectionRange(0,this.value.length)&#39; 有效果但在pc上会有错误。 最后用如下方法实现ios和pc端都能实现： 123&lt;input type=&quot;number&quot; onfocus=&quot;selected()&quot;/&gt;&lt;input type=&quot;number&quot; (focus)=&quot;selected()&quot;/&gt; &lt;ion-input type=&quot;text&quot; (ionFocus)=&quot;selected()&quot;&gt;&lt;/ion-input&gt; 123456789selected() &#123; try &#123; setTimeout(()=&gt;&#123; document.execCommand(&apos;SelectAll&apos;); &#125;); &#125; catch (err) &#123; console.log(err); &#125;&#125; 关于setSelectionRange 其他position：fixed 有时在ios上也会出现问题，写代码时不光看用chrome调试工具模拟的页面效果， 一定要在真机上调试。 随着功能模块越来越多，项目越来越大，我们可能需要懒加载，但在使用懒加载后我们的pwa版本在项目启动后断网，再连接网络没有办法加载断网前还未加载的模块。这个原因我们不得不改回原来的版本，我们的项目主要使用pwa版本，就目前来说启动速度还可以。]]></content>
      <tags>
        <tag>Ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic3踩坑体验（一）絮叨]]></title>
    <url>%2F2018%2F02%2F01%2Fionic3%E8%B8%A9%E5%9D%91%E4%BD%93%E9%AA%8C%EF%BC%88%E4%B8%80%EF%BC%89%E7%B5%AE%E5%8F%A8%2F</url>
    <content type="text"><![CDATA[ionic3踩坑体验（一）絮叨首先，所谓‘踩坑’，并不是说一定是什么ionic使用的难点、痛点，只是遇到什么问题，解决了想起来了就一下。为什么第一篇题目叫絮叨呢？ 因为我遇到‘坑’时，都把它记到了印象笔记中，所以我是把‘坑’都踩了一遍再来写这篇文章。也算是对ionic框架的总结吧，所以 第一篇就叫絮叨把。 当我们通过cli开始一个ionic应用时，会提示我们选择一个模版，空白、带侧边菜单、底部菜单等。其中super 会提供给我们懒加载的写法。 ios和android组件有不同的样式首先，ionic应用在ios设备和android设备的显示效果上默认是不相同的。我们可以通过设置config文件或[mode]=””让ionic组件使用ios或android样式，ios的默认样式会好看一点,但在android上某些显示会变得违和。1234567IonicModule.forRoot(MyApp,&#123; iconMode:&apos;ios&apos;,// 在整个应用程序中为所有图标使用的模式。可用选项：&quot;ios&quot;，&quot;md&quot; mode:&apos;ios&apos;//在整个应用程序中使用的模式。 &#125;) 单个组件可以以属性方式声明：比如1&lt;ion-segment [(ngModel)]=&quot;icons&quot; mode=&quot;md&quot;&gt; 路由跳转从一个tab的子页，跳转到另一个tab页，不能直接12345this.navCtrl.push()//可以这么实现this.navCtrl.goToRoot(ShopCartPage); // ShopCartPage 是tab组件名this.navCtrl.parent.select(2); // 2是跳转tab的index 注：ionic3关于路由跳转问题还是不少的，不过ionic4使用angular原生的机制了。 push和pop动画当我们自己写page中的header或为header修改一些样式，然后用ionic的ion-content时，我们进入该页或退出该页时，在苹果设备中可能会造成动画不统一。 安卓设备没有该问题，所以我们调用NavController.pop()时可以加ops对象{animation:’ md-transition’}，使用android默认动画效果。animation可以加的字符串有 md-transition, ios-transition and wp-transition. 这个动画应该可以自己定义，有空可以试一下。 ionic2/3 中使用懒加载的问题我们第一个ionic项目并没有使用懒加载，随着项目增大，开始考虑懒加载，我花了一些时间重构完后，发现了一个问题，我们将ionic项目作为网页应用利用manifest将应用放在iPad桌面，进入应用然后断网，再联网就再也不能加载还没有加载的模块了，因为这个项目现在速度还可以，其他工作任务比较重，这个问题就暂时放下了，将项目改回。]]></content>
      <tags>
        <tag>Ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再见2017，你好2018]]></title>
    <url>%2F2018%2F01%2F01%2F%E5%BF%862017%EF%BC%8C%E6%9C%9B2018%2F</url>
    <content type="text"><![CDATA[‘竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生’离开北京，回到沈阳]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular阻止事件冒泡]]></title>
    <url>%2F2017%2F08%2F08%2Fangular%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%2F</url>
    <content type="text"><![CDATA[Event Modifiers在实际项目中，我们经常需要在事件处理器中调用 preventDefault() 或 stopPropagation() 方法： preventDefault() - 如果事件可取消，则取消该事件，意味着该事件的所有默认动作都不会发生。需要注意的是该方法不会阻止该事件的冒泡。stopPropagation() - 阻止当前事件在 DOM 树上冒泡。对于 preventDefault() 方法，有一个经典的应用场景。即当我们希望点击链接在新窗口打开页面，但不希望当前页面跳转。这个时候可以使用 preventDefault() 阻止后面将要执行的浏览器默认动作。 &lt;a id=&quot;link&quot; href=&quot;https://segmentfault.com/a/1190000008754631&quot;&gt;Angular 4.x 修仙之路&lt;/a&gt; &lt;script&gt; document.getElementById(&apos;link&apos;).onclick = function(ev) { ev.preventDefault(); // 阻止浏览器默认动作 (页面跳转) window.open(this.href); // 在新窗口打开页面 }; &lt;/script&gt; 方式一&lt;div&gt; &lt;button (click)=&quot;$event.stopPropagation(); doSomething()&quot;&gt;Click me&lt;/button&gt; &lt;/div&gt; 方式二@Component({ selector: &apos;exe-app&apos;, template: ` &lt;div&gt; &lt;button (click)=&quot;doSomething($event)&quot;&gt;Click me&lt;/button&gt; &lt;/div&gt;` }) export class AboutComponent { doSomething($event: Event) { $event.stopPropagation(); // your logic } } 是不是感觉很麻烦，每次都得显式地调用 $event.stopPropagation() 方法。有没有更简便的方法呢？能不能使用声明式的语法？在 Vue 中可以通过声明式的方式，解决我们上面的问题。具体如下： &lt;!-- the click event&apos;s propagation will be stopped --&gt; &lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt; &lt;!-- the submit event will no longer reload the page --&gt; &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; &lt;!-- the click event will be triggered at most once --&gt; &lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt; 接下来我们也来基于 Angular 的指令系统，实现上述的功能。最终的使用示例如下： &lt;div class=&quot;parent&quot; (click)=&quot;fromParent()&quot;&gt; &lt;button class=&quot;child&quot; (click.stop)=&quot;fromChild()&quot;&gt;Click me&lt;/button&gt; &lt;/div&gt; 自定义 [click.stop] 指令import { Directive, Output, EventEmitter, Renderer2, ElementRef } from &apos;@angular/core&apos;; @Directive({ selector: &apos;[click.stop]&apos; }) export class StopPropagationDirective { @Output(&quot;click.stop&quot;) stopPropEvent = new EventEmitter(); unsubscribe: () =&gt; void; constructor( private renderer: Renderer2, // Angular 2.x导入Renderer private element: ElementRef) { } ngOnInit() { this.unsubscribe = this.renderer.listen( this.element.nativeElement, &apos;click&apos;, event =&gt; { event.stopPropagation(); this.stopPropEvent.emit(event); }); } ngOnDestroy() { this.unsubscribe(); } } [click.stop] 指令应用import { Component } from &apos;@angular/core&apos;; @Component({ selector: &apos;exe-app&apos;, template: ` &lt;div class=&quot;parent&quot; (click)=&quot;fromParent()&quot;&gt; &lt;button class=&quot;child&quot; (click.stop)=&quot;fromChild()&quot;&gt;Click me&lt;/button&gt; &lt;/div&gt; ` }) export class AppComponent { fromChild() { console.log(&apos;I am Child&apos;); } fromParent() { console.log(&apos;I am Parent&apos;); } } 以上代码成功运行后，当用户点击 Click me 按钮时，浏览器控制台只会输出 I am Child。若把 (click.stop) 改为 (click) ，当用户再次点击 Click me 按钮时，控制台就会输出两条信息。]]></content>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular中@ViewChild和@ContentChild的区别']]></title>
    <url>%2F2017%2F08%2F07%2FViewChild%E5%92%8C-ContentChild%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[@ViewChild文档解释 声明一个对子元素的引用。 ViewChild需要一个参数来选择元素。 如果参数是一个类型，一个指令或一个类型的组件将被绑定。 如果参数是一个字符串，字符串被解释为一个选择器。也就是一个元素包含模板变量（如 #child）。 在任何情况下，如果找到多个元素，那么只返回第一个。 这个子元素将在ngAfterViewInit()回调前被赋值。 @ContenChild文档解释 查询一个内容。 内容查询结果将在ngAfterContentInit()回调前完成。 并不好理解吧，我找到了StackOverflow上相关问题的答案]]></content>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[活着]]></title>
    <url>%2F2017%2F07%2F12%2F%E6%B4%BB%E7%9D%80%2F</url>
    <content type="text"><![CDATA[看了电影《活着》。富贵遭受了太多的苦，一个又一个。苦难不会因为你忍让它就可怜你。而人对苦难的忍受能力也要比想象的大。]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷宫游戏]]></title>
    <url>%2F2017%2F05%2F20%2F%E8%BF%B7%E5%AE%AB%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[来自HTML5秘籍 github地址迷宫游戏贪吃蛇小游戏 布置迷宫思路是选择一幅迷宫图片，把整幅图绘制到画布上。 当页面加载时，它会取得一张图片，然后把它绘制到画布上。 ///定义全局变量，保存画布及绘图上下文 var canvas; var context; window.onload = function () { canvas = document.getElementById(&apos;canvas&apos;); context = canvas.getContext(&quot;2d&quot;); //绘制迷宫背景 drawMaze(&quot;maze.png&quot;, 268, 5); //当用户按下键盘上的键时，运行processKey()函数 window.onkeydown = processKey; }; 以上代码并没有自己绘制迷宫背景，而是把这个任务交给了另一个名为drawMaze()的函数。 由于绘制迷宫的是一个独立的函数，因此就可以不局限于只绘制一个迷宫。只要在调用drawMaze()时传入迷宫图片的文件名以及笑脸的起始位置，就可以加载任何迷宫图片。 function drawMaze(mazeFile, startingX, startingY) { imgMaze = new Image(); imgMaze.onload = function () { // 调整画布大小 canvas.width = imgMaze.width; canvas.height = imgMaze.height; // 绘制迷宫 context.drawImage(imgMaze, 0, 0); // 绘制笑脸 x = startingX; y = startingY; var imgFace = document.getElementById(&apos;face&apos;); context.drawImage(imgFace, x, y); context.stroke(); // 10毫秒后绘制下一帧 setTimeout(drawFrame, 15); }; imgMaze.src = mazeFile; } 首先，定义一个处理图片onload事件并在图片加载完毕后绘制迷宫的函数。其次，它设置了图片对象的src属性，这样就会加载图片并在加载完毕后触发事件处理函数。与从隐藏的元素中取图片相比，这个两步方法稍微复杂那么一点，但为了让函数足够灵活，可以加载任意图片，就必须采取这种方法。 加载完迷宫图片后，代码会根据图片大小调整画布的大小，把笑脸图标放到正确的位置上，然后绘制笑脸图标。最后，调用setTimeout()开始绘制动画帧。 让笑脸动起来在用户按下键盘的方向键时，笑脸开始移动。比如，按向下键时，笑脸就会一直向下移动，不是碰到障碍或用户又按下其他方向键，就不会停下来。 为此，我们需要两个全局变量记录笑脸的速度。换句话说，就是就是记录笑脸在x轴和y轴方向上每一帧要移动多少像素。这两变量就是dx和dy。 var dx = 0; var dy = 0; 当用户按下键盘上的键时，画布调用processKey()函数。然后，该函数检查用户按下的是不是方向键，然后据以调整笑脸的速度。为了检测方向键，要用已知的值与用户按下键的键码进行比较。 function processKey(e) { // 如果笑脸在移动，停止 dx = 0; dy = 0; if (e.keyCode == 38) { dy = -1; } if (e.keyCode == 40) { dy = 1; } if (e.keyCode == 37) { dx = -1; } if (e.keyCode == 39) { dx = 1; } }]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为cordova生成的android应用签名]]></title>
    <url>%2F2017%2F05%2F03%2F%E4%B8%BAcordova%E7%94%9F%E6%88%90%E7%9A%84android%E5%BA%94%E7%94%A8%E7%AD%BE%E5%90%8D%2F</url>
    <content type="text"><![CDATA[1.配置环境 JDK之类，不管签不签名都需要，就不在这里说了 2.生成未经签名的apk文件cordova build -release android 这里要用release模式来生成 3.使用keytool工具生成数字证书keytool -genkey -v -keystore it-homer.keystore -alias it-homer.keystore -keyalg RSA -validity 2000 说明： 1）keytool是工具名称，-genkey意味着执行的是生成数字证书操作，-v表示将生成证书的详细信息打印出来，显示在dos窗口中； 2）-keystore it-homer.keystore 表示生成的数字证书的文件名为“ it-homer.keystore”（it-homer可以取自己的名字）； 3）-alias it-homer.keystore 表示证书的别名为“ it-homer.keystore”，当然可以不和上面的文件名一样； 4）-keyalg RSA 表示生成密钥文件所采用的算法为RSA； 5）-validity 2000 表示该数字证书的有效期为2000天，意味着2000天之后该证书将失效在执行上面的命令生成数字证书文件时，会提示你输入一些信息，包括证书的密码，示例如下： 4.使用jarsigner工具为Android应用程序签名jarsigner -verbose -keystore it-homer.keystore -signedjar notepad_signed.apk notepad.apk it-homer.keystore 说明： 1）jarsigner是工具名称，-verbose表示将签名过程中的详细信息打印出来，显示在dos窗口中； 2）-keystore it-homer.keystore 表示签名所使用的数字证书所在位置，这里没有写路径，表示在当前目录下； 3）-signedjar notepad_signed.apk notepad.apk 表示给notepad.apk文件签名(cordova生产为android-release-unsigned.apk)，签名后的文件名称为notepad_signed.apk； 4）最后面的 it-homer.keystore 表示证书的别名，对应于生成数字证书时-alias参数后面的名称]]></content>
      <tags>
        <tag>Cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重制知乎日报]]></title>
    <url>%2F2017%2F05%2F03%2F%E9%87%8D%E5%88%B6%E7%9F%A5%E4%B9%8E%E6%97%A5%E6%8A%A5%2F</url>
    <content type="text"><![CDATA[项目地址 github地址 ap下载地址 说明在酷安上看到一位安卓开发者写的一个他重制的知乎日报app,发现有知乎日报的api. 遂有了这个应用的诞生，鼓掌。 应用只有一点几M，比原应用小了近10倍，没有弹窗，没有广告，没有推送，不要多余权限，不会收集用户信息。。。 因为api不支持跨域，开发时可写一个node服务用来获取数据，完成页面开发时换成接口地址就可以了。cordova打包的app可以跨域。使用vue2.0和cordova开发手机应用跨域问题记录]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>Cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vue2.0和cordova开发手机应用跨域问题记录]]></title>
    <url>%2F2017%2F05%2F01%2F%E4%BD%BF%E7%94%A8vue2-0%E5%92%8Ccordova%E5%BC%80%E5%8F%91%E6%89%8B%E6%9C%BA%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近一直在练习使用vue2,恰巧在酷安有一款安卓开发者开发的重制知乎日报，受到一些启发，知乎日报是我很喜欢的应用，在网上找到别人整理的知乎日报接口，就想着用vue也写一个自己的知乎日报，在使用cordova打包成apk。 原来vue项目我使用的请求接口插件是vue-resource,但现在官方推荐的axios，在这里我也打算使用axios. 在vue可以使用axios + vue-axios,可以像原来的方法一样使用ajax了。 开发过程中我遇到的最大的一个问题就是跨域了。因为是第三方接口不支持cors，我想用jsonp试一下，但axios又不支持jsonp，我就使用了jQuery的getJSON()方法，很不幸接口并不支持JSONP. 我在网上找了一下，发现已经有前辈做过用vue 1和这个接口开发的知乎日报了，他使用的是用node转发这个接口。我也尝试这么做，在本地运行时我可以获取到接口中的数据，但当我将node文件部署到heroku上后，使用postman测试接口并不成功。后端知识有限也不知道问题出在哪。 这是他的接口，发现使用了nginx在github上问了一下，他只说可以使用nginx访问他的接口，但我是想我的接口能用，但我对nginx的使用仅限于本地开发时反向代理接口，对服务器端使用nginx实在不了解，而且我想是不是在自己的服务器才能使用nginx呢？这方面以后要学。 跨域问题困扰很久，但前两天晚上上床睡觉前，突然想到，我是想开发成一个apk应用，而跨域问题是在浏览器中存在的，那么问题来了，用cordova开发的应用还用考虑跨域吗？赶紧去了解了一下，不出所料通过白名单配置是可以不受跨域影响的。试验了一下，成功！config文件中 &lt;plugin name=&quot;cordova-plugin-whitelist&quot; spec=&quot;1&quot; /&gt; &lt;access origin=&quot;*&quot; /&gt; &lt;allow-intent href=&quot;http://*/*&quot; /&gt; &lt;allow-intent href=&quot;https://*/*&quot; /&gt; &lt;allow-intent href=&quot;tel:*&quot; /&gt; &lt;allow-intent href=&quot;sms:*&quot; /&gt; &lt;allow-intent href=&quot;mailto:*&quot; /&gt; &lt;allow-intent href=&quot;geo:*&quot; /&gt; 其中’‘标签表示域限制设置，” * “表示可以访问外部服务器。 index.html中修改标签改变csp（内容安全策略）,就可访问所有外部资源了。 &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src * &apos;self&apos; &apos;unsafe-inline&apos;;img-src * &apos;self&apos; data:;font-src &apos;self&apos; data:&quot;&gt; 修改图标和启动画安装splashscreen插件 cordova plugin add cordova-plugin-splashscreen 基本配置然后在config.xml文件中，添加以下代码 &lt;platform name=&quot;android&quot;&gt; &lt;icon density=&quot;ldpi&quot; src=&quot;res/icon/android/drawable-ldpi/icon.png&quot; /&gt; &lt;icon density=&quot;mdpi&quot; src=&quot;res/icon/android/drawable-mdpi/icon.png&quot; /&gt; &lt;icon density=&quot;hdpi&quot; src=&quot;res/icon/android/drawable-hdpi/icon.png&quot; /&gt; &lt;icon density=&quot;xhdpi&quot; src=&quot;res/icon/android/drawable-xhdpi/icon.png&quot; /&gt; &lt;icon density=&quot;xxhdpi&quot; src=&quot;res/icon/android/drawable-xxhdpi/icon.png&quot; /&gt; &lt;!-- 以下是欢迎页面，可根据需要进行添加 --&gt; &lt;splash density=&quot;land-hdpi&quot; src=&quot;res/screen/android/splash-land-hdpi.png&quot; /&gt; &lt;splash density=&quot;land-ldpi&quot; src=&quot;res/screen/android/splash-land-ldpi.png&quot; /&gt; &lt;splash density=&quot;land-mdpi&quot; src=&quot;res/screen/android/splash-land-mdpi.png&quot; /&gt; &lt;splash density=&quot;land-xhdpi&quot; src=&quot;res/screen/android/splash-land-xhdpi.png&quot; /&gt; &lt;splash density=&quot;port-hdpi&quot; src=&quot;res/screen/android/splash-port-hdpi.png&quot; /&gt; &lt;splash density=&quot;port-ldpi&quot; src=&quot;res/screen/android/splash-port-ldpi.png&quot; /&gt; &lt;splash density=&quot;port-mdpi&quot; src=&quot;res/screen/android/splash-port-mdpi.png&quot; /&gt; &lt;splash density=&quot;port-xhdpi&quot; src=&quot;res/screen/android/splash-port-xhdpi.png&quot; /&gt; &lt;/platform&gt; &lt;platform name=&quot;ios&quot;&gt; &lt;!-- iOS 8.0+ --&gt; &lt;!-- iPhone 6 Plus --&gt; &lt;icon src=&quot;res/icon/ios/icon-60@3x.png&quot; width=&quot;180&quot; height=&quot;180&quot; /&gt; &lt;!-- iOS 7.0+ --&gt; &lt;!-- iPhone / iPod Touch --&gt; &lt;icon src=&quot;res/icon/ios/icon-60.png&quot; width=&quot;60&quot; height=&quot;60&quot; /&gt; &lt;icon src=&quot;res/icon/ios/icon-60@2x.png&quot; width=&quot;120&quot; height=&quot;120&quot; /&gt; &lt;!-- iPad --&gt; &lt;icon src=&quot;res/icon/ios/icon-76.png&quot; width=&quot;76&quot; height=&quot;76&quot; /&gt; &lt;icon src=&quot;res/icon/ios/icon-76@2x.png&quot; width=&quot;152&quot; height=&quot;152&quot; /&gt; &lt;!-- iOS 6.1 --&gt; &lt;!-- Spotlight Icon --&gt; &lt;icon src=&quot;res/icon/ios/icon-40.png&quot; width=&quot;40&quot; height=&quot;40&quot; /&gt; &lt;icon src=&quot;res/icon/ios/icon-40@2x.png&quot; width=&quot;80&quot; height=&quot;80&quot; /&gt; &lt;!-- iPhone / iPod Touch --&gt; &lt;icon src=&quot;res/icon/ios/icon.png&quot; width=&quot;57&quot; height=&quot;57&quot; /&gt; &lt;icon src=&quot;res/icon/ios/icon@2x.png&quot; width=&quot;114&quot; height=&quot;114&quot; /&gt; &lt;!-- iPad --&gt; &lt;icon src=&quot;res/icon/ios/icon-72.png&quot; width=&quot;72&quot; height=&quot;72&quot; /&gt; &lt;icon src=&quot;res/icon/ios/icon-72@2x.png&quot; width=&quot;144&quot; height=&quot;144&quot; /&gt; &lt;!-- iPhone Spotlight and Settings Icon --&gt; &lt;icon src=&quot;res/icon/ios/icon-small.png&quot; width=&quot;29&quot; height=&quot;29&quot; /&gt; &lt;icon src=&quot;res/icon/ios/icon-small@2x.png&quot; width=&quot;58&quot; height=&quot;58&quot; /&gt; &lt;!-- iPad Spotlight and Settings Icon --&gt; &lt;icon src=&quot;res/icon/ios/icon-50.png&quot; width=&quot;50&quot; height=&quot;50&quot; /&gt; &lt;icon src=&quot;res/icon/ios/icon-50@2x.png&quot; width=&quot;100&quot; height=&quot;100&quot; /&gt; &lt;!-- 以下是欢迎页面，可根据需要进行添加 --&gt; &lt;splash src=&quot;res/screen/ios/Default~iphone.png&quot; width=&quot;320&quot; height=&quot;480&quot;/&gt; &lt;splash src=&quot;res/screen/ios/Default@2x~iphone.png&quot; width=&quot;640&quot; height=&quot;960&quot;/&gt; &lt;splash src=&quot;res/screen/ios/Default-Portrait~ipad.png&quot; width=&quot;768&quot; height=&quot;1024&quot;/&gt; &lt;splash src=&quot;res/screen/ios/Default-Portrait@2x~ipad.png&quot; width=&quot;1536&quot; height=&quot;2048&quot;/&gt; &lt;splash src=&quot;res/screen/ios/Default-Landscape~ipad.png&quot; width=&quot;1024&quot; height=&quot;768&quot;/&gt; &lt;splash src=&quot;res/screen/ios/Default-Landscape@2x~ipad.png&quot; width=&quot;2048&quot; height=&quot;1536&quot;/&gt; &lt;splash src=&quot;res/screen/ios/Default-568h@2x~iphone.png&quot; width=&quot;640&quot; height=&quot;1136&quot;/&gt; &lt;splash src=&quot;res/screen/ios/Default-667h.png&quot; width=&quot;750&quot; height=&quot;1334&quot;/&gt; &lt;splash src=&quot;res/screen/ios/Default-736h.png&quot; width=&quot;1242&quot; height=&quot;2208&quot;/&gt; &lt;splash src=&quot;res/screen/ios/Default-Landscape-736h.png&quot; width=&quot;2208&quot; height=&quot;1242&quot;/&gt; &lt;/platform&gt; 其他配置自动隐藏启动页面AutoHideSplashScreen（默认为：true） &lt;preference name=&quot;AutoHideSplashScreen&quot; value=&quot;true&quot; /&gt; 显示启动页面的时间长度SplashScreenDelay(默认为：3000) &lt;preference name=&quot;SplashScreenDelay&quot; value=&quot;3000&quot; /&gt; 若想禁用启动页面，可设置为： &lt;preference name=&quot;SplashScreenDelay&quot; value=&quot;0&quot;/&gt; 如果是iOS平台上想禁止启动页面，还需要添加 &lt;preference name=&quot;FadeSplashScreenDuration&quot; value=&quot;0&quot;/&gt; 启动页面淡入淡出的效果是否显示淡入淡出效果FadeSplashScreen(默认为：true) &lt;preference name=&quot;FadeSplashScreen&quot; value=&quot;false&quot;/&gt; 淡入淡出效果的执行时间长度FadeSplashScreenDuration(默认为：500) &lt;preference name=&quot;FadeSplashScreenDuration&quot; value=&quot;750&quot;/&gt; 注意：FadeSplashScreenDuration时间是包含在SplashScreenDelay的时间里的。启动页面是否允许旋转（默认为：true） &lt;preference name=&quot;ShowSplashScreenSpinner&quot; value=&quot;false&quot;/&gt; 插件还可以通过js代码调用，提供有以下两个方法：navigator.splashscreen.hide();//隐藏启动页面navigator.splashscreen.show();//显示启动页面在Android平台下的特殊设置 &lt;preference name=&quot;SplashMaintainAspectRatio&quot; value=&quot;true|false&quot; /&gt; &lt;preference name=&quot;SplashShowOnlyFirstTime&quot; value=&quot;true|false&quot; /&gt; SplashMaintainAspectRatio：选填项，默认为false。当设置为true时，则不会拉伸图片来填充屏幕，会以图片原始比例显示图片。SplashShowOnlyFirstTime：选填项，默认为true。当设置为false时，APP通过navigator.app.exitApp()代码退出app后，在下次打开APP时，还会显示启动页面。若为true时，就不会出现。 注： 安卓图标具体规格如下（存放目录：res/icon/android/） 36*36 drawable-ldpi/icon.png 48*48 drawable-mdpi/icon.png 72*72 drawable-hdpi/icon.png 96*96 drawable-xhdpi/icon.png 144*144 drawable-xxhdpi/icon.png iOS图标具体规格如下（存放目录：res/icon/ios/） 57*57 icon.png 114*114 icon@2x.png 29*29 icon-small.png 58*58 icon-small@2x.png 40*40 icon-40.png 80*80 icon-40@2x.png 50*50 icon-50.png 100*100 icon-50@2x.png 60*60 icon-60.png 120*120 icon-60@2x.png 180*180 icon-60@3x.png 72*72 icon-72.png 144*144 icon-72@2x.png 76*76 icon-76.png 152*152 icon-76@2x.png 应用程序启动页面安卓启动画面具体规格如下（存放目录：res/screen/android/） 960*720 splash-land-xhdpi.png 640*480 splash-land-hdpi.png 470*320 splash-land-mdpi.png 426*320 splash-land-ldpi.png 720*960 splash-port-xhdpi.png 480*640 splash-port-hdpi.png 320*470 splash-port-mdpi.png 320*426 splash-port-ldpi.png iOS启动画面具体规格如下（存放目录：res/screen/ios/） 320*480 Default~iphone.png 640*960 Default@2x~iphone.png 768*1024 Default-Portrait~ipad.png 1536*2048 Default-Portrait@2x~ipad.png 1024*768 Default-Landscape~ipad.png 2048*1536 Default-Landscape@2x~ipad.png 640*1136 Default-568h@2x~iphone.png 750*1334 Default-667h.png 1242*2208 Default-736h.png 2208*1242 Default-Landscape-736h.png]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线上部署heroku]]></title>
    <url>%2F2017%2F04%2F27%2F%E7%BA%BF%E4%B8%8A%E9%83%A8%E7%BD%B2heroku%2F</url>
    <content type="text"><![CDATA[由于知乎日报的api不支持跨域，所以用node代理接口，但我想在线上也可以用，所以尝试将node布到线上。 对于我一个没工作的穷人来讲一个拥有一定免费空间的平台当然是最好的选择————heroku 1写好我们我们的应用后，git初始化 git init 2添加到本地仓库 git add . 3添加一个叫Procfile的文件，内容是 web: node app.js 用来告诉heroku我们的程序是node的，从app.js启动 4在app.js我们需要有这么一句 app.listen(process.env.PORT || 5000); heroku 使用了主动的策略，主动提供一个环境变量 process.env.PORT 来供我们监听。 5我们去 https://www.heroku.com/ 申请个账号，然后下载它的工具包 https://toolbelt.heroku.com/当然这一步我们也可以放到第一步，执行第一步需要已经安装git，而安装heroku工具包会询问我们是否安装git 6在它的工具命令行里面，通过 heroku login 来登录，当然我们将heroku加到环境变量中去，然后在电脑命令行中直接执行 heroku login 上述步骤完成后，我们进入项目目录，执行 heroku create。这时候，heroku 会为我们随机取一个应用名字，并提供一个 git 仓库给我们。 https://stardee-daily-server.herokuapp.com/]]></content>
      <tags>
        <tag>heroku</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github上传本地代码失败]]></title>
    <url>%2F2017%2F04%2F10%2Fgithub%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E5%A4%B1%E8%B4%A5%2F</url>
    <content type="text"><![CDATA[问题：使用github的客户端上传本地代码失败了。（忘记截图了）就是这个报错 failed to sync this branch打开git shell用命令行先 git pull，再git push也不行。 原因：因为远程repository和我本地的repository冲突导致的。 解决方法：有如下几种解决方法： 1.使用强制push的方法： $ git push -u origin master -f 这样会使远程修改丢失，一般是不可取的，尤其是多人协作开发的时候。 2.push前先将远程repository修改pull下来 $ git pull origin master $ git push -u origin master 3.若不想merge远程和本地修改，可以先创建新的分支： $ git branch [name] 然后push $ git push -u origin [name]]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic应用图标启动画修改]]></title>
    <url>%2F2017%2F03%2F17%2Fionic%E5%BA%94%E7%94%A8%E5%9B%BE%E6%A0%87%E5%90%AF%E5%8A%A8%E7%94%BB%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[Ionic应用名字+应用图标+启动画的修改 方法/步骤1.修改名字修改config.xml–name标签 2。修改应用图标和启动画进入项目所在文件夹执行 ionic resources 执行该命令后，会自动在resources文件夹下创建已添加的平台名称的文件夹，把相应素材放到如下所示文件夹中 resources/android/icon/app.png—应用图标resources/android/splash/start.png—启动画 &lt;platform name=&quot;android&quot;&gt; &lt;icon src=&quot;resources/android/icon/app.png&quot; /&gt; &lt;splash src=&quot;resources/android/splash/start.png&quot;/&gt; &lt;/platform&gt; &lt;preference name=&quot;SplashScreen&quot; value=&quot;screen&quot;/&gt; &lt;preference name=&quot;SplashScreenDelay&quot; value=&quot;5000&quot; /&gt; 时间为5秒，如果不写则默认3秒 3.完成效果最后重新生成apk，运行即可。]]></content>
      <tags>
        <tag>Ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ionic安装和配置]]></title>
    <url>%2F2017%2F03%2F16%2Fionic%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[配置环境下载JDK，配置环境android SDK：安卓开发者网站（需要翻墙），有单独的Android SDK压缩包下载，也可以装Android Studio （ 我安装的是2.3版本，使用遇到了一个问题，提示我在SDK目录下的tools文件夹缺少一个文件，我是在网上找了一个原来版本的tools文件夹替换了原来的） 项目自动构建与启动 先安装node.js 安装cordova ionic npm install -g cordova ionic 创建运行项目 IOS创建运行项目ionic start myproject cd myproject ionic platform add ios ionic build ios ionic emulate ios android创建安装运行ionic start myproject或者ionic start myproject --skip-npm+npm install --save cd myproject ionic platform add android ionic build android ionic emulate android（模拟器运行） ionic run android （连接上手机运行）]]></content>
      <tags>
        <tag>Ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue通过js中引入本地图片]]></title>
    <url>%2F2017%2F03%2F07%2Fvue%E9%80%9A%E8%BF%87js%E4%B8%AD%E5%BC%95%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[问题：在template中中写图片的路径可以正确加载图片，但将图片的路径写在js中无法加载图片。 解决办法： 原因是模版中有图片解析器，放在模版会被webpack打包。而写在js里只是字符串webpack不会处理。 可以将图片放在最外层的static文件夹。或者使用import或require引入。]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2F2017%2F03%2F06%2FMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标题标题是每篇文章都需要也是最常用的格式，Markdown 支持两种标题的语法.第一种只要在这段文字前加 # 号即可。 # 一级标题 ## 二级标题 ### 三级标题 以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。 第二种利用 = （最高阶标题）和 - （第二阶标题），例如： This is an H1 ============= This is an H2 ------------- 列表-熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。 引用-如果你需要引用一小段别处的句子，那么就要用引用的格式。只需要在文本前加入 &gt; 这种尖括号（大于号）即可 图片与链接插入链接与插入图片的语法很像，区别在一个 !号 图片为：![](){ImgCap}{/ImgCap} 链接为：[]() 插入图片的地址需要图床，我用的是七牛。 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。 例如：这里是粗体 这里是斜体 表格| Tables | Are | Cool | | ------------- |:-------------:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码框需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来使用 tab 键即可缩进。 分割线分割线的语法只需要三个 * 号。]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack工程化创建vue项目]]></title>
    <url>%2F2017%2F03%2F06%2Fwebpack%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%88%9B%E5%BB%BAvue%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[安装vue-cli脚手架构建工具：npm install --g vue-cli 进入选定目录：cd demo 在选定目录中： vue init webpack firstVue 初始化一个项目，其中webpack是构建工具，即整个项目是基于webpack的。firstVue是整个项目文件夹的名称 cd进入项目文件夹安装项目所需依赖：运行命令 npm(cnpm) install 运行项目：在项目目录运行命令 npm run dev 用热加载的方式运行我们的应用，热加载可以让我们在修改完代码后不用手动刷新浏览器就能实时看到修改后的效果。其中“run”对应的是package.json文件中scripts字段中的dev,也就是node build/dev-server.js命令的一个快捷方式。]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前路漫漫]]></title>
    <url>%2F2017%2F03%2F03%2F%E5%89%8D%E8%B7%AF%E6%BC%AB%E6%BC%AB%2F</url>
    <content type="text"><![CDATA[今天继续学习用node写web服务器。 昨天打算用的是express框架，今天看了廖雪峰老师的教程打算使用koa2了，async和await的出现好像前段时间学习的python，有点熟悉的感觉。模板引擎也打算由原来的swig改用Nunjucks. 今天看到一个人写的静态博客写得很好看，用的Hexo框架和我原来学过一点JekyII框架功能来说差不多，但模版好像更好看一点。又想写一个。 现在想学的想做的太多了，有node写服务器端、python写服务器端，学习vue+vueX，写静态博客。。。]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建博客]]></title>
    <url>%2F2017%2F02%2F01%2Fhexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hexo+github搭建博客需要我们先安装git，node.js和github的帐号 搭建过程在github上我们需要创建一个名为username.github.io的仓库，uesrname为我们的github用户名，然后在设置中启用github page打开命令行工具进入你想要创建项目的磁盘 新建文件夹mkdir projectname 进入该文件夹cd projectname 安装hexonpm install -g hexo 初始化hexohexo init 生成静态页面hexo g 启动本地服务，主要用于预览效果hexo s 可以在浏览器中输入http://localhost:4000 打开项目根目录下的_config.yml文件，找到最下的内容改成如下形式，其中username同上为你的github用户名 deploy: type: git repo: git@github.com:username/username.github.io.git branch: master 然后在命令行中执行如下命令 npm install hexo-deployer-git --save 执行部署命令hexo d 当我们想更换主题时，将下载的主题放在themes文件夹下，并更改根目录下的_config.yml下的theme属性的值为当前主题名称。再按主题所要求的配置进行修改。有一些主题使用sass，需要我们安装hexo-renderer-sass,我们执行 npm install hexo-renderer-sass --save 很可能是网络问题，导致报错。我们需要使用cnpm安装如果已经使用npm安装，我们先要卸载hexo-renderer-sass再安装，不然还会报错，如果还是不行那就都删掉，重来一遍 常用命令每次部署需要使用hexo clean（一般并不需要） hexo generate（hexo g）#生成静态页面至public目录 hexo deploy（hexo d）#将.deploy目录部署到GitHub 其他常用命令：hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo help # 查看帮助 hexo version #查看Hexo的版本]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie、session和token]]></title>
    <url>%2F2016%2F02%2F22%2Fcookie%E3%80%81session%E5%92%8Ctoken%2F</url>
    <content type="text"><![CDATA[cookie浏览器向服务器发送请求时，服务器会将少量数据（识别用户的数据）返回浏览器，浏览器会将这些数据存放在硬盘或内存中（响应报文以set-cookie消息头返回给浏览器）。浏览器再次访问服务器时，以cookie消息头携带cookie。 会话cookie和持久cookie 会话cookie。不设置过期时间，cookie生命周期为会话期间。关闭浏览器窗口，cookie就消失了。 持久cookie。设置了过期时间，保存在硬盘上。 存储在硬盘上的cookie可以在不同的浏览器进程间共享。对于保存在内存的cookie，不同浏览器有不同处理方式。 设置cookie在cookie设置中，可以用escape()函数进行编码，取值用unescape()进行解码。设置cookie时可以直接给document.cookie赋值 document.cookie=&apos;userId=212&apos;; document.xookie=&apos;userName=joe&apos;; 后面的值不会覆盖前面的值，它采用一种累加机制。]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
